using System.CodeDom.Compiler;
using System.Collections.Immutable;
using System.IO;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Qread.Internals;
using Qread.Models;
using Qread.Sources;

namespace Qread.Generators;

[Generator]
public sealed class DataReadersGenerator : IIncrementalGenerator
{
    private static void EndContainers(TypeInternal type, IndentedTextWriter writer)
    {
        foreach (var _ in type.Containers)
            writer.EndBlock();
    }

    private static void GenerateCode(
        SourceProductionContext context,
        ImmutableArray<DataReaderGenerationTarget> targets
    )
    {
        foreach (var target in targets)
        {
            if (context.CancellationToken.IsCancellationRequested)
                return;

            var baseWriter = new StringWriter();
            var indentWriter = new IndentedTextWriter(baseWriter);

            indentWriter.Write(
                $"""
                // <auto-generated />
                #nullable enable
                {(!target.IsExact ? "using System.Collections.Frozen;" : "")}
                using System.Data;
                {(target.Namespace is null ? "" : $"\nnamespace {target.Namespace};\n")}
                
                """
            );
            StartContainers(target.Type, indentWriter);
            GenerateFromDataReaderMethod(target.Type, target.IsExact, indentWriter);
            indentWriter.WriteLineNoTabs("");

            if (!target.IsExact)
            {
                GenerateNestedFromDataReaderMethod(target.Type, indentWriter);
                indentWriter.WriteLineNoTabs("");
            }

            GenerateAsyncEnumerableFromDataReaderMethod(target, indentWriter);
            EndContainers(target.Type, indentWriter);

            var hintName = $"{target.Type.FullNameIgnoreNullable}.g.cs";
            context.AddSource(hintName, SourceText.From(baseWriter.ToString(), Encoding.UTF8));
        }
    }

    private static void GenerateFromDataReaderMethod(
        TypeInternal type,
        bool isExact,
        IndentedTextWriter writer
    )
    {
        writer.WriteLine(
            $"public static global::{type.FullNameIgnoreNullable} FromDataReader(IDataReader reader)"
        );
        writer.StartBlock();

        if (!isExact)
        {
            GeneratePropertyIndices(writer);
            writer.WriteLine("return FromDataReader(reader, propIndices, null)!;");
            writer.EndBlock();
            return;
        }

        writer.WriteLine($"var instance = new global::{type.FullNameIgnoreNullable}");
        writer.StartBlock();

        for (var i = 0; i < type.Properties.Length; i++)
        {
            var prop = type.Properties[i];
            var setter = GeneratePropertySetter(prop, isExact, i);
            writer.WriteLine(
                $"{prop.Name} = {setter}{(i < type.Properties.Length - 1 ? "," : "")}"
            );
        }

        writer.Indent--;
        writer.WriteLine("};");
        writer.WriteLine("return instance;");
        writer.EndBlock();
    }

    private static void GenerateAsyncEnumerableFromDataReaderMethod(
        DataReaderGenerationTarget target,
        IndentedTextWriter writer
    )
    {
        writer.WriteLine(
            $"public static async IAsyncEnumerable<global::{target.Type.FullName}> AsyncEnumerableFromDataReader(global::System.Data.IDataReader reader, [global::System.Runtime.CompilerServices.EnumeratorCancellation] CancellationToken cancellationToken)"
        );
        writer.StartBlock();
        writer.WriteLine("var dbReader = reader as global::System.Data.Common.DbDataReader;");
        writer.WriteLineNoTabs("");
        writer.WriteLine("while (await ReadAsync())");
        writer.StartBlock();
        writer.WriteLine("var instance = FromDataReader(reader);");
        writer.WriteLine("yield return instance;");
        writer.EndBlock();
        writer.WriteLineNoTabs("");
        writer.WriteLine("async ValueTask<bool> ReadAsync()");
        writer.StartBlock();
        writer.WriteLine("return dbReader is not null");
        writer.WriteLineIndented("? await dbReader.ReadAsync(cancellationToken)");
        writer.WriteLineIndented(": reader.Read();");
        writer.EndBlock();
        writer.EndBlock();
    }

    private static void GenerateNestedFromDataReaderMethod(
        TypeInternal type,
        IndentedTextWriter writer
    )
    {
        writer.WriteLine(
            $"public static global::{type.FullNameIgnoreNullable}? FromDataReader(IDataReader reader, Dictionary<string, int> propIndices, string? prefix)"
        );
        writer.StartBlock();

        foreach (var prop in type.Properties)
        {
            if (prop.IsNullable)
                continue;

            if (prop.DbType is null && prop.Type.CanConstruct)
            {
                var varName = $"{char.ToLowerInvariant(prop.Name[0])}{prop.Name.Substring(1)}";
                writer.WriteLine(
                    $$"""
                    var {{varName}} = global::{{prop.Type.FullNameIgnoreNullable}}.FromDataReader(reader, propIndices, $"{prefix}{{prop.Name}}_");
                    """
                );
                writer.WriteLineNoTabs("");
                writer.WriteLine($"if ({varName} is null)");
                writer.Indent++;
                writer.WriteLine("return null;");
                writer.WriteLineNoTabs("");
                writer.Indent--;
            }
            else
            {
                writer.WriteLine(
                    $"if (!propIndices.TryGetValue($\"{{prefix}}{prop.Name}\", out var index{prop.Name})"
                );
                writer.Indent++;
                writer.WriteLine($"|| reader.IsDBNull(index{prop.Name}))");
                writer.Indent++;
                writer.WriteLine("return null;");
                writer.WriteLineNoTabs("");
                writer.Indent -= 2;
            }
        }

        writer.WriteLine($"var instance = new global::{type.FullNameIgnoreNullable}");
        writer.StartBlock();

        for (var i = 0; i < type.Properties.Length; i++)
        {
            var prop = type.Properties[i];
            var setter =
                prop.IsNullable || prop.DbType is not null || !prop.Type.CanConstruct
                    ? GeneratePropertySetter(prop, false, i)
                    : $"{char.ToLowerInvariant(prop.Name[0])}{prop.Name.Substring(1)}";
            writer.WriteLine(
                $"{prop.Name} = {setter}{(i < type.Properties.Length - 1 ? "," : "")}"
            );
        }

        writer.Indent--;
        writer.WriteLine("};");
        writer.WriteLine("return instance;");
        writer.EndBlock();
    }

    private static void GeneratePropertyIndices(IndentedTextWriter writer)
    {
        writer.WriteLine("var propIndices = new Dictionary<string, int>(reader.FieldCount);");
        writer.WriteLineNoTabs("");
        writer.WriteLine("for (var i = reader.FieldCount - 1; i >= 0; i--)");
        writer.StartBlock();
        writer.WriteLine("var columnName = reader.GetName(i);");
        writer.WriteLine("propIndices[columnName] = i;");
        writer.EndBlock();
        writer.WriteLineNoTabs("");
    }

    private static string GeneratePropertySetter(Property prop, bool isExact, int i)
    {
        var index =
            isExact ? i.ToString()
            : prop.IsNullable ? $"index{prop.Name}"
            : $"propIndices[$\"{{prefix}}{prop.Name}\"]";
        var orNullCondition =
            isExact || !prop.IsNullable
                ? ""
                : $"!propIndices.TryGetValue($\"{{prefix}}{prop.Name}\", out var index{prop.Name}) ? null : ";
        var orNull = prop.IsNullable ? orNullCondition + $"reader.IsDBNull({index}) ? null : " : "";
        return prop.Type.IsEnum
            ? $"{orNull}(global::{prop.Type.FullName})reader.GetInt32({index})"
            : prop.DbType switch
            {
                DbTypeInternal.Bool => $"{orNull}reader.GetBoolean({index})",
                DbTypeInternal.Byte =>
                    $"{orNull}{(prop.IsArray ? $"(byte[])reader.GetValue({index})" : $"reader.GetByte({index})")}",
                DbTypeInternal.Char => $"{orNull}reader.GetChar({index})",
                DbTypeInternal.DateOnly =>
                    $"{orNull}DateOnly.FromDateTime(reader.GetDateTime({index}))",
                DbTypeInternal.DateTime => $"{orNull}reader.GetDateTime({index})",
                DbTypeInternal.DateTimeOffset =>
                    $"{orNull}(DateTimeOffset)reader.GetValue({index})",
                DbTypeInternal.Decimal => $"{orNull}reader.GetDecimal({index})",
                DbTypeInternal.Double => $"{orNull}reader.GetDouble({index})",
                DbTypeInternal.Single => $"{orNull}reader.GetFloat({index})",
                DbTypeInternal.Guid => $"{orNull}reader.GetGuid({index})",
                DbTypeInternal.Int16 => $"{orNull}reader.GetInt16({index})",
                DbTypeInternal.Int32 => $"{orNull}reader.GetInt32({index})",
                DbTypeInternal.Int64 => $"{orNull}reader.GetInt64({index})",
                DbTypeInternal.String => $"{orNull}reader.GetString({index})",
                DbTypeInternal.TimeSpan => $"{orNull}(TimeSpan)reader.GetValue({index})",
                _ => isExact || !prop.Type.CanConstruct
                    ? $"true ? throw new Exception(\"Unknown type {prop.Type.FullName}.\") : default"
                    : $$"""
                        global::{{prop.Type.FullNameIgnoreNullable}}.FromDataReader(reader, propIndices, $"{prefix}{{prop.Name}}_"){{(
                            prop.IsNullable ? "" : "!"
                        )}}
                        """,
            };
    }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var typeCache = new TypeCache();
        context.RegisterPostInitializationOutput(ctx => ctx.AddGenerateDataReaderAttributeSource());
        var provider = context.SyntaxProvider.ForAttributeWithMetadataName(
            $"{Constants.Namespace}.{GenerateDataReaderAttribute.Name}",
            (node, _) =>
                node
                    is ClassDeclarationSyntax
                        or RecordDeclarationSyntax
                        or StructDeclarationSyntax,
            (ctx, _) =>
                DataReaderGenerationTarget.TryCreate(ctx, typeCache, out var target) ? target : null
        );
        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(provider.Collect()),
            (ctx, targets) =>
                GenerateCode(
                    ctx,
                    targets.Right.OfType<DataReaderGenerationTarget>().ToImmutableArray()
                )
        );
    }

    private static void StartContainers(TypeInternal type, IndentedTextWriter writer)
    {
        foreach (var parent in type.Containers)
        {
            writer.WriteLine($"partial {parent.TypeKind.ToDeclaration()} {parent.Name}");
            writer.StartBlock();
        }
    }
}
