using System.CodeDom.Compiler;
using System.Collections.Immutable;
using System.IO;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using Qread.Internals;
using Qread.Models;
using Qread.Sources;

namespace Qread.Generators;

[Generator]
public sealed class DataReadersGenerator : IIncrementalGenerator
{
    private static void EndContainers(TypeInternal type, IndentedTextWriter writer)
    {
        foreach (var _ in type.Containers)
            writer.EndBlock();
    }

    private static void GenerateCode(
        SourceProductionContext context,
        ImmutableArray<DataReaderGenerationTarget> targets
    )
    {
        foreach (var target in targets)
        {
            if (context.CancellationToken.IsCancellationRequested)
                return;

            var baseWriter = new StringWriter();
            var indentWriter = new IndentedTextWriter(baseWriter);

            indentWriter.Write(
                $"""
                // <auto-generated />
                #nullable enable
                {(!target.IsExact ? "using System.Collections.Frozen;" : "")}
                using System.Data;

                namespace {target.Namespace};

                
                """
            );
            StartContainers(target.Type, indentWriter);

            if (!target.IsExact)
            {
                indentWriter.WriteLine(
                    "private static FrozenDictionary<string, int>? _propIndices;"
                );
                indentWriter.WriteLineNoTabs("");
            }

            GenerateFromDataReaderMethod(target.Type, target.IsExact, indentWriter);
            indentWriter.WriteLineNoTabs("");
            GenerateAsyncEnumerableFromDataReaderMethod(target, indentWriter);
            EndContainers(target.Type, indentWriter);

            var hintName = $"{target.Type.FullName}.g.cs";
            context.AddSource(hintName, SourceText.From(baseWriter.ToString(), Encoding.UTF8));
        }
    }

    private static void GenerateFromDataReaderMethod(
        TypeInternal type,
        bool isExact,
        IndentedTextWriter writer
    )
    {
        writer.WriteLine(
            $"public static global::{type.FullName} FromDataReader(IDataReader reader)"
        );
        writer.StartBlock();

        if (!isExact)
            GeneratePropertyIndices(writer);

        writer.WriteLine($"var instance = new global::{type.FullNameIgnoreNullable}");
        writer.StartBlock();

        for (var i = 0; i < type.Properties.Length; i++)
        {
            var prop = type.Properties[i];
            var setter = GeneratePropertySetter(prop, isExact, i);
            writer.WriteLine(
                $"{prop.Name} = {setter}{(i < type.Properties.Length - 1 ? "," : "")}"
            );
        }

        writer.Indent--;
        writer.WriteLine("};");
        writer.WriteLine("return instance;");
        writer.EndBlock();
    }

    private static void GenerateAsyncEnumerableFromDataReaderMethod(
        DataReaderGenerationTarget target,
        IndentedTextWriter writer
    )
    {
        writer.WriteLine(
            $"public static async IAsyncEnumerable<global::{target.Type.FullName}> AsyncEnumerableFromDataReader(global::System.Data.IDataReader reader, [global::System.Runtime.CompilerServices.EnumeratorCancellation] CancellationToken cancellationToken)"
        );
        writer.StartBlock();
        writer.WriteLine("var dbReader = reader as global::System.Data.Common.DbDataReader;");
        writer.WriteLine("while (await ReadAsync())");
        writer.StartBlock();
        writer.WriteLine("var instance = FromDataReader(reader);");
        writer.WriteLine("yield return instance;");
        writer.EndBlock();
        writer.WriteLineNoTabs("");
        writer.WriteLine("async ValueTask<bool> ReadAsync()");
        writer.StartBlock();
        writer.WriteLine("return dbReader is not null");
        writer.WriteLineIndented("? await dbReader.ReadAsync(cancellationToken)");
        writer.WriteLineIndented(": reader.Read();");
        writer.EndBlock();
        writer.EndBlock();
    }

    private static void GeneratePropertyIndices(IndentedTextWriter writer)
    {
        writer.WriteLine("if (_propIndices is null)");
        writer.StartBlock();
        writer.WriteLine("var unfrozenPropIndices = new Dictionary<string, int>();");
        writer.WriteLineNoTabs("");
        writer.WriteLine("for (var i = reader.FieldCount - 1; i >= 0; i--)");
        writer.StartBlock();
        writer.WriteLine("var columnName = reader.GetName(i);");
        writer.WriteLine("unfrozenPropIndices[columnName] = i;");
        writer.EndBlock();
        writer.WriteLineNoTabs("");
        writer.WriteLine("_propIndices = unfrozenPropIndices.ToFrozenDictionary();");
        writer.EndBlock();
        writer.WriteLineNoTabs("");
    }

    private static string GeneratePropertySetter(Property prop, bool isExact, int i)
    {
        var index =
            isExact ? i.ToString()
            : prop.IsNullable ? "index"
            : $"_propIndices[\"{prop.Name}\"]";
        var orNullCondition =
            isExact || !prop.IsNullable
                ? ""
                : $"!_propIndices.TryGetValue(\"{prop.Name}\", out var index) ? null : ";
        var orNull = prop.IsNullable ? orNullCondition + $"reader.IsDBNull({index}) ? null : " : "";
        return prop.Type.IsEnum
            ? $"{orNull}(global::{prop.Type.FullName})reader.GetInt32({index})"
            : prop.DbType switch
            {
                DbTypeInternal.Bool => $"{orNull}reader.GetBoolean({index})",
                DbTypeInternal.Byte =>
                    $"{orNull}{(prop.IsArray ? $"(byte[])reader.GetValue({index})" : $"reader.GetByte({index})")}",
                DbTypeInternal.Char => $"{orNull}reader.GetChar({index})",
                DbTypeInternal.DateOnly =>
                    $"{orNull}DateOnly.FromDateTime(reader.GetDateTime({index}))",
                DbTypeInternal.DateTime => $"{orNull}reader.GetDateTime({index})",
                DbTypeInternal.DateTimeOffset =>
                    $"{orNull}(DateTimeOffset)reader.GetValue({index})",
                DbTypeInternal.Decimal => $"{orNull}reader.GetDecimal({index})",
                DbTypeInternal.Double => $"{orNull}reader.GetDouble({index})",
                DbTypeInternal.Single => $"{orNull}reader.GetFloat({index})",
                DbTypeInternal.Guid => $"{orNull}reader.GetGuid({index})",
                DbTypeInternal.Int16 => $"{orNull}reader.GetInt16({index})",
                DbTypeInternal.Int32 => $"{orNull}reader.GetInt32({index})",
                DbTypeInternal.Int64 => $"{orNull}reader.GetInt64({index})",
                DbTypeInternal.String => $"{orNull}reader.GetString({index})",
                DbTypeInternal.TimeSpan => $"{orNull}(TimeSpan)reader.GetValue({index})",
                _ => $"throw new Exception(\"Unknown type {prop.Type.FullName}.\")",
            };
    }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddGenerateDataReaderAttributeSource());
        var provider = context.SyntaxProvider.ForAttributeWithMetadataName(
            $"{Constants.Namespace}.{GenerateDataReaderAttribute.Name}",
            (node, _) =>
                node
                    is ClassDeclarationSyntax
                        or RecordDeclarationSyntax
                        or StructDeclarationSyntax,
            static (ctx, _) =>
                DataReaderGenerationTarget.TryCreate(ctx, out var target) ? target : null
        );
        context.RegisterSourceOutput(
            context.CompilationProvider.Combine(provider.Collect()),
            (ctx, targets) =>
                GenerateCode(
                    ctx,
                    targets.Right.OfType<DataReaderGenerationTarget>().ToImmutableArray()
                )
        );
    }

    private static void StartContainers(TypeInternal type, IndentedTextWriter writer)
    {
        foreach (var parent in type.Containers)
        {
            writer.WriteLine($"partial {parent.TypeKind.ToDeclaration()} {parent.Name}");
            writer.StartBlock();
        }
    }
}
